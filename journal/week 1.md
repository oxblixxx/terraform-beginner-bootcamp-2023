# Terraform Beginner Bootcamp 2023 - Week 1


## STANDARD MODULE STRUCTURE (1.0.0)

### ROOT STRUCTURE

```sh
.
├── README.md
├── main.tf
├── provider.tf
├── variables.tf
├── variable.tfvars
├── outputs.tf
```


[Standard moudle structure](https://developer.hashicorp.com/terraform/language/modules/develop/structure)

### VARIABLE
Declaring an input variable could be done in various ways in terraform. Environment variables can be stored on your `terraform cloud` as well. Provider credentials needs to be stored on `terraform cloud`. Also `terraform variables` can me stored on the cloud as well, a variable.tf file must be created with the necessary arguments then the key and values are stored on the cloud.

### VARIABLE PRECEDENCE

Terraform environment variable precedence is the order in which Terraform looks for environment variables when loading variables. Terraform loads variables in the following order, with later sources taking precedence over earlier ones:

1. Environment variables 
2. The variable.tfvars file, if present The variable.tfvars.json file, if present
3. Any .auto.tfvars or .auto.tfvars.json files, processed in lexical order of their filenames
4. Any -var and -var-file options on the command line, in the order they are provided




### TERRAFORM.TFVARS
Terraform.tfvars is a file that contains the values for variables that are defined in the variable.tf file. It is a common way to store and manage the values for variables in your Terraform configuration.


### -VAR-FILE FLAG
The -var-file flag is used to pass the values for variables to Terraform from a file. This can be useful for storing sensitive values, such as database passwords and API keys, outside of your Terraform configuration. You can then use the -var-file flag to pass the file to Terraform when you apply your configuration.


### AUTO.TFVARS
You can use the auto.tfvars file to store sensitive values, such as database passwords and API keys, outside of your Terraform configuration. You can then use the -var-file flag to pass the auto.tfvars file to Terraform when you apply your configuration.



---

## CONFIGURATION DRIFT (1.1.0)

### RESOURCE DRIFT
Incase of a mistake of deleting a resource via the console, terraform informs the next time `terraform apply` is run that the resource doesn't exist anymore and will be creating a new one.

### TERRAFRM IMPORT
Import command is a special Terraform command that allows you to import existing infrastructure into Terraform.

*NB*: Ensure to check the resource documentation to check if the resource can be imported.

```
terraform import aws_instance.web i-12345678
```


### TERRAFORM IMPORT.TF
Import.tf is a special Terraform file that allows you to import existing infrastructure into Terraform. It is similar to the terraform import command, but it allows you to import multiple resources at once and to specify additional options, such as the Terraform resource type and the state file that you want to import the resources into.[^1] I imported an existing EC2 instance already created via console, the block of code is in `import.tf`


```
terraform plan -generate-config-out=generated.tf
```

Running that command shows the import changeset to fetch the resource details in the import block in generated.tf



### TERRAFORM GENERATED.TF

Generated.tf is a file that is generated by Terraform when you run the terraform import command or when you apply a Terraform configuration that contains an import block. The generated.tf file contains the Terraform configuration for the resources that were imported.



```sh
│ Error: Conflicting configuration arguments
│ 
│   with aws_instance.webserver,
│   on generated.tf line 20, in resource "aws_instance" "webserver":
│   20:   ipv6_addresses                       = []
│ 
│ "ipv6_addresses": conflicts with ipv6_address_count
╵
╷
│ Error: Conflicting configuration arguments
│ 
│   with aws_instance.webserver,
│   on generated.tf line 19, in resource "aws_instance" "webserver":
│   19:   ipv6_address_count                   = 0
│ 
│ "ipv6_address_count": conflicts with ipv6_addresses
```

### FIXING THE ERROR ABOVE
I simply opened the **generated.tf** file, I commented **ipv6_address_count**. The instruction to rectify the issue is to comment either **ipv6_addresses or ipv6_addresses_count** then you can run **terraform apply**




## CREATING TERRAHOUSE MODULE
[Module sources](https://developer.hashicorp.com/terraform/language/modules/sources) Terraform modules are a way to package and reuse Terraform configurations. They can be used to create reusable components of your infrastructure.



```sh
├── modules/
│   ├── nestedA/
│   │   ├── README.md
│   │   ├── variables.tf
│   │   ├── main.tf
│   │   ├── outputs.tf
```

### ROOT MODULE
In the root modules, the variables should be declared in the `module block` and in the `variables.tf` file.

```terraform
module "consul" {
  source = "./modules/terrahouse_aws"
  user-uuid = var.user-uuid
  environment = var.environment
  name = var.name
}

```

## CDN IMPLEMENTATION
You can do this using the CloudFront console, the AWS CLI, or the AWS SDK. But we will automate using `Terraform`. When you create a distribution, you need to specify the origin server that you want to deliver content from. You can also specify other settings, such as the cache behavior and the TTL.

### UPLOADING OBEJCT TO S3
It's best practice to explore the documentation as `chatGPT` gives deprecated versions of resources. Uploading in the  `bucket` will be done with the [aws_s3_object](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_object) resource of terraform.

### DATA SOURCES
The path.module and path.root functions in Terraform are used to get the paths to the module and root directory of your Terraform configuration.

- path.module : The path.module function returns the filesystem path of the directory containing the module where the path.module expression is placed[^2]. 

- path.root : The path.root function returns the filesystem path of the root module of your Terraform configuration[^2].

### eTAG ATTRIBUTE
The etag attribute in Terraform is used to specify the entity tag (ETag) for an S3 object. The ETag is a unique identifier for the object and is used to verify that the object has not been changed since it was last uploaded.

```
etag = filemd5("${path.root}/path/to/file")
```

### OBJECT VALIDATIION
While uploading objects into the bucket, they can be validated if the file exists using the validation block and using the function `fileexists()` and if it does not exist a condition can be set with an error message to output[^3]`

### TERRAFORM FUNCTIONS
There are various types of [fuctions in terraform](https://developer.hashicorp.com/terraform/language/functions). `Jsonencode` functions was used to encode a the `bucket policy` to a JSON string.

### DATA SOURCES PROVIDER
A data source provider in Terraform is a plugin that provides Terraform with the ability to retrieve information about external resources, such as cloud APIs, databases, or other configuration files. Data source providers are different from resource providers, which enable Terraform to manage and provision external resources.

```
data "aws_instance" "example" {
  id = "i-1234567890abcdef0"
}
```
The above block of code  is used to get the instance type of the EC2 instance then it can be referenced as data.aws_instancew.example.

### LOCALS

Locals in Terraform are named values that can be assigned and used in your code. Locals are declared using a locals block. The block can contain any number of named values, which are assigned using the = operator. Locals can be used in any expression in Terraform, and they can be referenced using the local. prefix.

```
locals {
  region = "us-east-1"
  instance_type = "t2.micro"
}
```
It can be referenced as below:
```
resource "aws_instance" "example" {
  ami = "ami-01234567890abcdef0"
  instance_type = local.instance_type
  tags = {
    Name = "Example Instance"
    Region = local.region
  }
}
```

### ERROR FACED
After succesfully deploying the infrastructure, I copied the distrubution domain name to display my html contents. Instead it downloaded the file. To fix this, login to AWS console, navigate to the created Cloudfront distribution, click on `invalidations`  create invalidation and this obejct path [^4]
```
/*
```

CloudFront invalidations are a way to remove objects from the CloudFront cache before their TTL (time to live) expires. This is useful when you need to make changes to your website or application and want to ensure that visitors see the latest version of your content.CloudFront invalidations are a way to remove objects from the CloudFront cache before their TTL (time to live) expires. This is useful when you need to make changes to your website or application and want to ensure that visitors see the latest version of your content. 

## CONTENT VERSIONING
Content versioning is a feature that allows you to track and manage changes to your content over time.

### THE TERRAFORM_DATA MANAGED RESOURCE TYPE
The [terraform_data managed](https://developer.hashicorp.com/terraform/language/resources/terraform-data) resource type is a special resource type that can be used to store values which need to follow a managed resource lifecycle, and for triggering provisioners when there is no other logical managed resource in which to place them. 
`Plain data values such as Local Values and Input Variables don't have any side-effects to plan against and so they aren't valid in replace_triggered_by. You can use terraform_data's behavior of planning an action each time input changes to indirectly use a plain value to trigger replacement.`

```
variable "revision" {
  default = 1
}

resource "terraform_data" "replacement" {
  input = var.revision
}

# This resource has no convenient attribute which forces replacement,
# but can now be replaced by any change to the revision variable value.
resource "example_database" "test" {
  lifecycle {
    replace_triggered_by = [terraform_data.replacement]
  }
}
```


### LIFECYCLE 

The [lifecycle block](https://developer.hashicorp.com/terraform/language/meta-arguments/lifecycle) in Terraform is used to control the way that a resource is created, updated, and destroyed. The lifecycle block can be used to specify the following properties:
- create_before_destroy: This property tells Terraform to create the new resource before destroying the old one. This can be useful for resources that need to be online continuously, such as load --  balancers and databases.
- ignore_changes: This property tells Terraform to ignore changes to certain attributes of the resource. This can be useful for resources that have attributes that change frequently but do not affect the resource's behavior.
- replace_triggered_by: This property tells Terraform to replace the resource whenever the specified attribute changes. This can be useful for resources that need to be updated whenever a related resource changes.

## AUTOMATING CLOUDFRONT INVALIDATION

### CLI INAVALIDATION OF CLOUDFRONT
Invalidation of cloudfront can be done through AWS CLI command. Using Terraform isn't best practices to do it, `configuration mangement tools` like Ansible can be used. The AWS CLI command to run is
```
aws cloudfront create-invalidation --distribution-id YOUR_DISTRIBUTION_ID --paths '/*'
```

### PROVISIONER

Terraform provisioners are a way to execute commands on remote resources after they have been created. This can be useful for a variety of tasks, such as installing software, configuring applications, and deploying infrastructure. `Terraform data` is a replacement of `Nulll resource`


```
variable "revision" {
  default = 1
}


resource "terraform_data" "replacement" {
  input = var.revision  
}

# This resource has no convenient attribute which forces replacement,
# but can now be replaced by any change to the revision variable value.
resource "example_database" "test" {
  lifecycle {
    replace_triggered_by = [terraform_data.replacement]
  }
   provisioner "local-exec" {
    command = "bootstrap-hosts.sh"
  }
}

```

### local-exec and remote-exec
- Local-exec: This provisioner executes commands on the local machine where Terraform is running.
- Remote-exec: This provisioner executes commands on a remote resource, such as an EC2 instance or Kubernetes cluster.

### ERROR
I hardcode the `distribution ID` I got an error, fixed it by passing in `--distribution-id ${aws_cloudfront_distribution.s3_distribution.id}` and changing `--all-paths` to `paths`
```
Error: local-exec provisioner error
│ 
│  with module.terrahouse_aws.terraform_data.cdn_invalidate,
│  on modules/terrahouse_aws/resource_cdn.tf line 73, in resource "terraform_data" "cdn_invalidate":
│  73:  provisioner "local-exec" {
│ 
│ Error running command '  aws cloudfront create-invalidation \
│   --distribution-id E421N6I3204BU4 \ 
│   --all-paths '/*'
Note: AWS CLI version 2, the latest: 
│ major version of the AWS CLI, is now stable and recommended for general
│ use. For more information, see the AWS CLI version 2 installation
│ instructions at:
│ https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html
│ 
│ usage: aws [options] <command> <subcommand> [<subcommand> ...] [parameters]
│ To see help text, you can run:
│ 
│  aws help
│  aws <command> help
│  aws <command> <subcommand> help
│ 
│ Unknown options:  
│ /bin/sh: 3: --all-paths: not found
│ 
╵
Operation failed:
```

`NB: Reason for content versioning is because we don't want changes on our infrastructure everytime the etags changes but when we update var.content_version which should trigger the invalidations as well`

### Uploading multiple files

### FOR EACH

### FILESET



[^1]:https://developer.hashicorp.com/terraform/language/import/generating-configuration
[^2]:https://developer.hashicorp.com/terraform/language/expressions/references#path-module
[^3]:https://developer.hashicorp.com/terraform/language/functions/fileexists
[^4]:https://christinavhastenrath.medium.com/how-to-manually-invalidate-aws-cloudfront-b36a2ab4e1be
