# Terraform Beginner Bootcamp 2023 - Week 1


## STANDARD MODULE STRUCTURE (1.0.0)

### ROOT STRUCTURE

```sh
.
├── README.md
├── main.tf
├── provider.tf
├── variables.tf
├── variable.tfvars
├── outputs.tf
```


[Standard moudle structure](https://developer.hashicorp.com/terraform/language/modules/develop/structure)

### VARIABLE
Declaring an input variable could be done in various ways in terraform. Environment variables can be stored on your `terraform cloud` as well. Provider credentials needs to be stored on `terraform cloud`. Also `terraform variables` can me stored on the cloud as well, a variable.tf file must be created with the necessary arguments then the key and values are stored on the cloud.

### VARIABLE PRECEDENCE

Terraform environment variable precedence is the order in which Terraform looks for environment variables when loading variables. Terraform loads variables in the following order, with later sources taking precedence over earlier ones:

1. Environment variables 
2. The variable.tfvars file, if present The variable.tfvars.json file, if present
3. Any .auto.tfvars or .auto.tfvars.json files, processed in lexical order of their filenames
4. Any -var and -var-file options on the command line, in the order they are provided




### TERRAFORM.TFVARS
Terraform.tfvars is a file that contains the values for variables that are defined in the variable.tf file. It is a common way to store and manage the values for variables in your Terraform configuration.


### -VAR-FILE FLAG
The -var-file flag is used to pass the values for variables to Terraform from a file. This can be useful for storing sensitive values, such as database passwords and API keys, outside of your Terraform configuration. You can then use the -var-file flag to pass the file to Terraform when you apply your configuration.


### AUTO.TFVARS
You can use the auto.tfvars file to store sensitive values, such as database passwords and API keys, outside of your Terraform configuration. You can then use the -var-file flag to pass the auto.tfvars file to Terraform when you apply your configuration.



---

## CONFIGURATION DRIFT (1.1.0)

### RESOURCE DRIFT
Incase of a mistake of deleting a resource via the console, terraform informs the next time `terraform apply` is run that the resource doesn't exist anymore and will be creating a new one.

### TERRAFRM IMPORT
Import command is a special Terraform command that allows you to import existing infrastructure into Terraform.

*NB*: Ensure to check the resource documentation to check if the resource can be imported.

```
terraform import aws_instance.web i-12345678
```


### TERRAFORM IMPORT.TF
Import.tf is a special Terraform file that allows you to import existing infrastructure into Terraform. It is similar to the terraform import command, but it allows you to import multiple resources at once and to specify additional options, such as the Terraform resource type and the state file that you want to import the resources into.[^1] I imported an existing EC2 instance already created via console, the block of code is in `import.tf`


```
terraform plan -generate-config-out=generated.tf
```

Running that command shows the import changeset to fetch the resource details in the import block in generated.tf



### TERRAFORM GENERATED.TF

Generated.tf is a file that is generated by Terraform when you run the terraform import command or when you apply a Terraform configuration that contains an import block. The generated.tf file contains the Terraform configuration for the resources that were imported.



```sh
│ Error: Conflicting configuration arguments
│ 
│   with aws_instance.webserver,
│   on generated.tf line 20, in resource "aws_instance" "webserver":
│   20:   ipv6_addresses                       = []
│ 
│ "ipv6_addresses": conflicts with ipv6_address_count
╵
╷
│ Error: Conflicting configuration arguments
│ 
│   with aws_instance.webserver,
│   on generated.tf line 19, in resource "aws_instance" "webserver":
│   19:   ipv6_address_count                   = 0
│ 
│ "ipv6_address_count": conflicts with ipv6_addresses
```

### FIXING THE ERROR ABOVE
I simply opened the **generated.tf** file, I commented **ipv6_address_count**. The instruction to rectify the issue is to comment either **ipv6_addresses or ipv6_addresses_count** then you can run **terraform apply**




## CREATING TERRAHOUSE MODULE
[Module sources](https://developer.hashicorp.com/terraform/language/modules/sources) Terraform modules are a way to package and reuse Terraform configurations. They can be used to create reusable components of your infrastructure.



```sh
├── modules/
│   ├── nestedA/
│   │   ├── README.md
│   │   ├── variables.tf
│   │   ├── main.tf
│   │   ├── outputs.tf
```

### ROOT MODULE
In the root modules, the variables should be declared in the `module block` and in the `variables.tf` file.

```terraform
module "consul" {
  source = "./modules/terrahouse_aws"
  user-uuid = var.user-uuid
  environment = var.environment
  name = var.name
}

```

## CDN IMPLEMENTATION
You can do this using the CloudFront console, the AWS CLI, or the AWS SDK. But we will automate using `Terraform`. When you create a distribution, you need to specify the origin server that you want to deliver content from. You can also specify other settings, such as the cache behavior and the TTL.

### UPLOADING OBEJCT TO S3
It's best practice to explore the documentation as `chatGPT` gives deprecated versions of resources. Uploading in the  `bucket` will be done with the [aws_s3_object](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_object) resource of terraform.

### DATA SOURCES
The path.module and path.root functions in Terraform are used to get the paths to the module and root directory of your Terraform configuration.

- path.module : The path.module function returns the filesystem path of the directory containing the module where the path.module expression is placed[^2]. 

- path.root : The path.root function returns the filesystem path of the root module of your Terraform configuration[^2].

### eTAG ATTRIBUTE
The etag attribute in Terraform is used to specify the entity tag (ETag) for an S3 object. The ETag is a unique identifier for the object and is used to verify that the object has not been changed since it was last uploaded.

```
etag = filemd5("${path.root}/path/to/file")
```

### OBJECT VALIDATIION
While uploading objects into the bucket, they can be validated if the file exists using the validation block and using the function `fileexists()` and if it does not exist a condition can be set with an error message to output[^3]`

### DATA SOURCES PROVIDER
A data source provider in Terraform is a plugin that provides Terraform with the ability to retrieve information about external resources, such as cloud APIs, databases, or other configuration files. Data source providers are different from resource providers, which enable Terraform to manage and provision external resources.

```
data "aws_instance" "example" {
  id = "i-1234567890abcdef0"
}
```
The above block of code  is used to get the instance type of the EC2 instance then it can be referenced as data.aws_instancew.example.

### LOCALS

Locals in Terraform are named values that can be assigned and used in your code. Locals are declared using a locals block. The block can contain any number of named values, which are assigned using the = operator. Locals can be used in any expression in Terraform, and they can be referenced using the local. prefix.

```
locals {
  region = "us-east-1"
  instance_type = "t2.micro"
}
```
It can be referenced as below:
```
resource "aws_instance" "example" {
  ami = "ami-01234567890abcdef0"
  instance_type = local.instance_type
  tags = {
    Name = "Example Instance"
    Region = local.region
  }
}
```

### ERROR FACED
After succesfully deploying the infrastructure, I copied the distrubution domain name to display my html contents. Instead it downloaded the file. To fix this, login to AWS console, navigate to the created Cloudfront distribution, click on `invalidations`  create invalidation and this obejct path
```
/*
```

CloudFront invalidations are a way to remove objects from the CloudFront cache before their TTL (time to live) expires. This is useful when you need to make changes to your website or application and want to ensure that visitors see the latest version of your content.CloudFront invalidations are a way to remove objects from the CloudFront cache before their TTL (time to live) expires. This is useful when you need to make changes to your website or application and want to ensure that visitors see the latest version of your content. [^4]



[^1]:https://developer.hashicorp.com/terraform/language/import/generating-configuration
[^2]:https://developer.hashicorp.com/terraform/language/expressions/references#path-module
[^3]:https://developer.hashicorp.com/terraform/language/functions/fileexists
[^4]:https://christinavhastenrath.medium.com/how-to-manually-invalidate-aws-cloudfront-b36a2ab4e1be
